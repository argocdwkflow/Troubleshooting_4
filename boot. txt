Parfait.
Voici les commandes Linux exactes, dans lâ€™ordre, niveau expert, prÃªtes Ã  Ãªtre copiÃ©es/collÃ©es.
ğŸ‘‰ Cas BIOS (Legacy) â€” je note Ã  la fin les diffÃ©rences UEFI.
âœ… Commandes techniques Linux â€“ dÃ©placement de /boot vers un nouveau disque
PHASE 0 â€” VÃ©rification du mode de boot
Copy code
Bash
[ -d /sys/firmware/efi ] && echo "UEFI" || echo "BIOS"
PHASE 1 â€” Identifier le nouveau disque
(aprÃ¨s ajout du VMDK dans VMware)
Copy code
Bash
lsblk
ğŸ‘‰ HypothÃ¨se :
Copy code

/dev/sdb  (nouveau disque)
PHASE 2 â€” CrÃ©er la table de partitions (BIOS)
Copy code
Bash
parted /dev/sdb --script mklabel msdos
PHASE 3 â€” CrÃ©er la partition /boot
Copy code
Bash
parted /dev/sdb --script mkpart primary ext4 1MiB 100%
PHASE 4 â€” Formater la partition
Copy code
Bash
mkfs.ext4 /dev/sdb1
PHASE 5 â€” Monter temporairement le nouveau /boot
Copy code
Bash
mount /dev/sdb1 /mnt
PHASE 6 â€” Copier le contenu de /boot
Copy code
Bash
rsync -avHAX /boot/ /mnt/
âœ”ï¸ Ne rien supprimer sur lâ€™ancien /boot
PHASE 7 â€” PrÃ©parer le chroot pour GRUB
Copy code
Bash
mount --bind /dev  /mnt/dev
mount --bind /proc /mnt/proc
mount --bind /sys  /mnt/sys
chroot /mnt
PHASE 8 â€” Installer GRUB (mode BIOS)
âš ï¸ Installer GRUB sur le DISQUE, pas sur la partition
Copy code
Bash
grub2-install /dev/sdb
grub2-mkconfig -o /boot/grub2/grub.cfg
exit
PHASE 9 â€” Mettre Ã  jour /etc/fstab (rollback-safe)
RÃ©cupÃ©rer lâ€™UUID :
Copy code
Bash
blkid /dev/sdb1
Ã‰diter /etc/fstab :
Copy code
Fstab
# Ancien /boot conservÃ© pour rollback
# UUID=OLD-SDA1-UUID  /boot  ext4  defaults  0 0

UUID=NEW-SDB1-UUID    /boot  ext4  defaults  0 0
PHASE 10 â€” VÃ©rification avant reboot
Copy code
Bash
mount -a
df -h /boot
PHASE 11 â€” Reboot contrÃ´lÃ©
Copy code
Bash
reboot
PHASE 12 â€” Validation post-reboot
Copy code
Bash
lsblk
mount | grep boot
uname -r
df -h /boot
ğŸ” DiffÃ©rences si le systÃ¨me est en UEFI (rappel rapide)
Ã€ la place des phases 2â€“4 :
Copy code
Bash
parted /dev/sdb --script mklabel gpt
parted /dev/sdb --script mkpart EFI fat32 1MiB 601MiB
parted /dev/sdb --script set 1 esp on
parted /dev/sdb --script mkpart BOOT ext4 601MiB 100%

mkfs.vfat -F32 /dev/sdb1
mkfs.ext4 /dev/sdb2
GRUB UEFI :
Copy code
Bash
grub2-install --target=x86_64-efi \
  --efi-directory=/boot/efi \
  --bootloader-id=redhat \
  --recheck
ğŸ”´ Commandes volontairement NON utilisÃ©es
âŒ pvmove
âŒ pvremove
âŒ lvreduce
âŒ parted resize
âŒ modification de sda
ğŸ§  Phrase expert Ã  retenir
This procedure relocates /boot to a dedicated disk using standard Linux tools, without modifying the system disk or LVM, ensuring minimal risk and immediate rollback.
Si tu veux, je peux maintenant :
ğŸ”§ transformer Ã§a en script bash
ğŸ¤– fournir une version Ansible auto BIOS/UEFI
ğŸ“‹ donner une checklist Go/No-Go
ğŸ§¾ Ã©crire une procÃ©dure PDF officielle
Dis-moi ğŸ‘

Parfait â€” voici le cas UEFI uniquement, avec les commandes Linux exactes, dans lâ€™ordre, niveau expert / prod / CAB-ready.
ğŸ‘‰ Objectif : dÃ©placer /boot vers un nouveau VMDK dÃ©diÃ© sans toucher Ã  sda ni au LVM, avec rollback immÃ©diat.
âœ… ProcÃ©dure UEFI â€“ Commandes techniques Linux
PHASE 0 â€” VÃ©rifier quâ€™on est bien en UEFI
Copy code
Bash
[ -d /sys/firmware/efi ] && echo "UEFI mode" || echo "NOT UEFI"
PHASE 1 â€” Identifier le nouveau disque
(aprÃ¨s ajout du VMDK dans VMware)
Copy code
Bash
lsblk
HypothÃ¨se :
Copy code

/dev/sdb   4G   (nouveau disque)
PHASE 2 â€” CrÃ©er la table GPT (obligatoire en UEFI)
Copy code
Bash
parted /dev/sdb --script mklabel gpt
PHASE 3 â€” CrÃ©er les partitions EFI et /boot
Partition EFI (ESP)
Copy code
Bash
parted /dev/sdb --script mkpart EFI fat32 1MiB 601MiB
parted /dev/sdb --script set 1 esp on
Partition /boot
Copy code
Bash
parted /dev/sdb --script mkpart BOOT ext4 601MiB 100%
PHASE 4 â€” Formater les partitions
Copy code
Bash
mkfs.vfat -F32 /dev/sdb1
mkfs.ext4 /dev/sdb2
PHASE 5 â€” Monter temporairement le nouveau /boot
Copy code
Bash
mount /dev/sdb2 /mnt
mkdir -p /mnt/efi
mount /dev/sdb1 /mnt/efi
PHASE 6 â€” Copier le contenu existant
Copier /boot
Copy code
Bash
rsync -avHAX /boot/ /mnt/
Copier /boot/efi
Copy code
Bash
rsync -avHAX /boot/efi/ /mnt/efi/
âš ï¸ Ne rien supprimer sur lâ€™ancien /boot
PHASE 7 â€” PrÃ©parer le chroot pour GRUB
Copy code
Bash
mount --bind /dev  /mnt/dev
mount --bind /proc /mnt/proc
mount --bind /sys  /mnt/sys
chroot /mnt
PHASE 8 â€” RÃ©installer GRUB en mode UEFI (Ã©tape clÃ©)
Copy code
Bash
grub2-install \
  --target=x86_64-efi \
  --efi-directory=/boot/efi \
  --bootloader-id=redhat \
  --recheck
GÃ©nÃ©rer la configuration :
Copy code
Bash
grub2-mkconfig -o /boot/grub2/grub.cfg
exit
PHASE 9 â€” Mettre Ã  jour /etc/fstab (rollback-safe)
RÃ©cupÃ©rer les UUID :
Copy code
Bash
blkid /dev/sdb1
blkid /dev/sdb2
Ã‰diter /etc/fstab :
Copy code
Fstab
# Ancien /boot conservÃ© pour rollback
# UUID=OLD-SDA1-UUID  /boot      ext4  defaults       0 0
# UUID=OLD-EFI-UUID   /boot/efi  vfat  umask=0077    0 0

UUID=NEW-SDB2-UUID    /boot      ext4  defaults       0 0
UUID=NEW-SDB1-UUID    /boot/efi  vfat  umask=0077    0 0
PHASE 10 â€” VÃ©rification AVANT reboot
Copy code
Bash
mount -a
df -h /boot
df -h /boot/efi
ğŸ‘‰ Les deux doivent pointer vers /dev/sdb*.
PHASE 11 â€” Reboot contrÃ´lÃ©
Copy code
Bash
reboot
PHASE 12 â€” Validation post-reboot (OBLIGATOIRE)
Copy code
Bash
lsblk
mount | grep boot
uname -r
df -h /boot
df -h /boot/efi
Attendu :
/boot â†’ /dev/sdb2
/boot/efi â†’ /dev/sdb1
Boot OK, kernel chargÃ© normalement
ğŸ”´ RÃ¨gles dâ€™or (UEFI)
âŒ Ne PAS modifier sda
âŒ Ne PAS supprimer sda1
âŒ Ne PAS toucher au LVM
âœ… GRUB installÃ© sur la nouvelle ESP
âœ… Ancien /boot conservÃ© pour rollback
ğŸ§  Phrase expert (UEFI)
We relocated /boot and the EFI System Partition to a dedicated disk and reinstalled GRUB in UEFI mode without modifying the system disk, ensuring minimal risk and immediate rollback.
Si tu veux la suite :
ğŸ”§ script Bash auto-UEFI
ğŸ¤– playbook Ansible auto-dÃ©tection BIOS/UEFI
ğŸ“‹ checklist Go/No-Go CAB
ğŸ§¾ procÃ©dure PDF officielle
Dis-moi ğŸ’ª


Bonne question â€” et la rÃ©ponse est nuancÃ©e selon /boot vs ESP (/boot/efi).
âœ… Pour /boot : ext4 recommandÃ©, XFS possible mais pas mon choix â€œprod-safeâ€
RecommandÃ© en entreprise : /boot en ext4
XFS sur /boot peut fonctionner sur RHEL 9, mais câ€™est plus sensible cÃ´tÃ© compatibilitÃ©/chaÃ®ne de boot (GRUB + modules + anciens patterns dâ€™upgrade). En CAB, ext4 passe toujours, XFS dÃ©clenche souvent des questions inutiles.
ğŸ‘‰ Conclusion N3 : mets ext4 pour /boot.
âœ… Pour /boot/efi (UEFI ESP) : obligatoire en vfat
Lâ€™ESP doit Ãªtre FAT (vfat/FAT32).
Donc XFS impossible pour /boot/efi.
Architecture recommandÃ©e (UEFI)
/boot/efi â†’ vfat (FAT32) ~ 600 MiB
/boot â†’ ext4 2â€“4 GiB
Si tu veux quand mÃªme XFS pour /boot
Je te donne la commande, mais avec lâ€™avertissement â€œnon recommandÃ©â€ :
Copy code
Bash
mkfs.xfs -f /dev/sdb2
Puis le fstab :
Copy code
Fstab
UUID=NEW-SDB2-UUID  /boot  xfs   defaults  0 0
âš ï¸ Si tu fais Ã§a, je conseille fortement :
valider que GRUB lit bien /boot en XFS (grub2-install + grub2-mkconfig)
faire 2 reboots de validation
garder lâ€™ancien /boot intact pour rollback
Phrase CAB (simple)
For UEFI systems, the EFI System Partition must be FAT32. For /boot, ext4 is the safest and most universally supported choice; XFS is possible but not recommended for minimizing bootloader compatibility risks.
Si tu me dis si vous Ãªtes 100% UEFI et si vous avez une policy standard FS, je te donne la variante exacte â€œconforme standard interneâ€.