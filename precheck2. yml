Voici un rôle Ansible complet (prêt pour AAP) qui fait exactement :
✅ Déduire le RHEL major (7/8/9)
✅ Construire l’URL kernel_version_...-rhel-<major>-<arch>
✅ Tester le port 443 vers la capsule
✅ Télécharger le fichier dans /tmp via get_url
✅ Lire le contenu (kernel target)
✅ Nettoyage du fichier /tmp/... même en cas d’échec (always)
✅ Aucun enregistrement Satellite
Arborescence du rôle
Copy code

roles/
  sat_precheck_kernel/
    defaults/main.yml
    tasks/main.yml
    README.md
roles/sat_precheck_kernel/defaults/main.yml
Copy code
Yaml
# Capsule / Satellite endpoint
sat_precheck_capsule_fqdn: "capsule-bp2i-prod.fr.net.intra"

# Base path du fichier kernel_versions sur la capsule
sat_precheck_kernel_base_path: "/pub/kernel_versions"

# Nom exact de ton fichier (pattern)
# Exemple: kernel_version_BP2I_lfe-prod_ccv-rhel-7-x86_64
sat_precheck_kernel_file_prefix: "kernel_version_BP2I_lfe-prod_ccv-rhel"

# Arch (par défaut, la fact Ansible renvoie x86_64 sur RHEL)
sat_precheck_arch: "{{ ansible_architecture | default('x86_64') }}"

# TLS validation (mets true si CA interne OK sur les hosts)
sat_precheck_validate_certs: false

# Timeouts
sat_precheck_tcp_timeout: 3
sat_precheck_https_timeout: 5

# Où télécharger (temp)
sat_precheck_tmp_dir: "/tmp"

# Autoriser seulement RHEL 7/8/9 (sécurité)
sat_precheck_supported_majors: ["7", "8", "9"]

# Si true => fail si 443 KO ou download KO
sat_precheck_fail_hard: false
roles/sat_precheck_kernel/tasks/main.yml
Copy code
Yaml
---
- name: Définir RHEL major
  ansible.builtin.set_fact:
    sat_precheck_rhel_major: "{{ ansible_distribution_major_version | string }}"
  changed_when: false

- name: Vérifier OS supporté (RHEL 7/8/9)
  ansible.builtin.fail:
    msg: "OS non supporté: {{ ansible_distribution }} {{ ansible_distribution_version }} (major={{ sat_precheck_rhel_major }})"
  when:
    - ansible_distribution != "RedHat"
    - sat_precheck_rhel_major not in sat_precheck_supported_majors

- name: Construire URL et chemins
  ansible.builtin.set_fact:
    sat_precheck_kernel_file: "{{ sat_precheck_kernel_file_prefix }}-{{ sat_precheck_rhel_major }}-{{ sat_precheck_arch }}"
    sat_precheck_kernel_url: "https://{{ sat_precheck_capsule_fqdn }}{{ sat_precheck_kernel_base_path }}/{{ sat_precheck_kernel_file }}"
    sat_precheck_tmp_file: "{{ sat_precheck_tmp_dir }}/{{ sat_precheck_kernel_file }}"
  changed_when: false

- name: Init résultat
  ansible.builtin.set_fact:
    sat_precheck:
      capsule: "{{ sat_precheck_capsule_fqdn }}"
      rhel_major: "{{ sat_precheck_rhel_major }}"
      arch: "{{ sat_precheck_arch }}"
      url: "{{ sat_precheck_kernel_url }}"
      port_443_ok: false
      download_ok: false
      http_status: null
      kernel_version: ""
      error: ""
  changed_when: false

- name: Check port 443 + download /tmp + lecture + cleanup
  block:
    - name: Check TCP 443 vers la capsule
      ansible.builtin.wait_for:
        host: "{{ sat_precheck_capsule_fqdn }}"
        port: 443
        timeout: "{{ sat_precheck_tcp_timeout }}"
        state: started
      register: _tcp443
      failed_when: false
      changed_when: false

    - name: Marquer 443 OK/KO
      ansible.builtin.set_fact:
        sat_precheck: "{{ sat_precheck | combine({'port_443_ok': (_tcp443 is succeeded)}) }}"
      changed_when: false

    - name: Télécharger kernel_version dans /tmp (get_url)
      ansible.builtin.get_url:
        url: "{{ sat_precheck_kernel_url }}"
        dest: "{{ sat_precheck_tmp_file }}"
        mode: '0644'
        validate_certs: "{{ sat_precheck_validate_certs }}"
        timeout: "{{ sat_precheck_https_timeout }}"
      register: _dl
      failed_when: false
      changed_when: false

    - name: Mettre à jour statut download + http_status
      ansible.builtin.set_fact:
        sat_precheck: >-
          {{
            sat_precheck | combine({
              'download_ok': (_dl is succeeded),
              'http_status': (_dl.status | default(None)),
              'error': (_dl.msg | default(''))
            })
          }}
      changed_when: false

    - name: Lire contenu du fichier téléchargé
      ansible.builtin.slurp:
        src: "{{ sat_precheck_tmp_file }}"
      register: _slurp
      when: _dl is succeeded
      changed_when: false

    - name: Extraire kernel_version
      ansible.builtin.set_fact:
        sat_precheck: "{{ sat_precheck | combine({'kernel_version': (_slurp.content | b64decode | trim)}) }}"
      when: _dl is succeeded
      changed_when: false

    - name: Fail hard si demandé (443 KO ou download KO)
      ansible.builtin.fail:
        msg: >-
          Precheck KO:
          443_ok={{ sat_precheck.port_443_ok }},
          download_ok={{ sat_precheck.download_ok }},
          http={{ sat_precheck.http_status }},
          err={{ sat_precheck.error }}
      when:
        - sat_precheck_fail_hard | bool
        - (not sat_precheck.port_443_ok) or (not sat_precheck.download_ok)

  rescue:
    - name: Capturer erreur bloc
      ansible.builtin.set_fact:
        sat_precheck: "{{ sat_precheck | combine({'error': 'Unexpected error during precheck block'}) }}"
      changed_when: false

    - name: Fail hard si demandé (exception)
      ansible.builtin.fail:
        msg: "Precheck KO (exception): {{ sat_precheck.error }}"
      when: sat_precheck_fail_hard | bool

  always:
    - name: Nettoyage du fichier temporaire /tmp
      ansible.builtin.file:
        path: "{{ sat_precheck_tmp_file }}"
        state: absent
      changed_when: false

- name: Afficher résultat final
  ansible.builtin.debug:
    var: sat_precheck
roles/sat_precheck_kernel/README.md (minimal)
Copy code
Md
# sat_precheck_kernel

Rôle de pré-check: vérifie access capsule (TCP 443) + télécharge le fichier kernel_version dans /tmp, lit son contenu, puis supprime le fichier.

## Variables importantes
- sat_precheck_capsule_fqdn (default: capsule-bp2i-prod.fr.net.intra)
- sat_precheck_kernel_file_prefix (default: kernel_version_BP2I_lfe-prod_ccv-rhel)
- sat_precheck_validate_certs (default: false)
- sat_precheck_fail_hard (default: false)

## Output
Le rôle définit un fact `sat_precheck` contenant:
- port_443_ok
- download_ok
- http_status
- kernel_version
- error
Exemple d’appel (playbook AAP)
Copy code
Yaml
- hosts: all
  gather_facts: true
  roles:
    - role: sat_precheck_kernel
      vars:
        sat_precheck_capsule_fqdn: "capsule-bp2i-prod.fr.net.intra"
        sat_precheck_validate_certs: false
        sat_precheck_fail_hard: false
Résultat attendu (par host)
Tu obtiens un objet sat_precheck :
port_443_ok: true/false
download_ok: true/false
http_status: 200/404/…
kernel_version: "4.18.0-..." (exemple)
error: "..."
Si tu veux, je peux te donner en plus :
une sortie CSV/JSON consolidée (idéale pour AAP job artifacts),
et/ou un mode “precheck_only” à intégrer directement dans ton rôle existant satellite_register.