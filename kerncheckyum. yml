OK ‚úÖ Je te donne tout : le dossier templates/ avec tous les fichiers Jinja + un tasks/main.yml complet qui :
met FAILED le host si 443 ferm√©/timeout
continue sur les autres hosts (id√©al pour des milliers)
met FAILED le job global √† la fin si au moins 1 host a port_443_ok=false
‚ö†Ô∏è Important : pour que le ‚Äúfail global fin de job‚Äù soit fiable, garde la strat√©gie Ansible par d√©faut (linear). Si ton playbook utilise strategy: free, le run_once peut s‚Äôex√©cuter avant que tous les hosts aient fini (dans ce cas je te donne une variante ‚Äú2 plays‚Äù dans le playbook, si tu veux).
üìÅ Arborescence
Copy code

roles/satellite_precheck_kernel/
‚îú‚îÄ tasks/
‚îÇ  ‚îî‚îÄ main.yml
‚îî‚îÄ templates/
   ‚îú‚îÄ tcp_method.j2
   ‚îú‚îÄ tcp_rc.j2
   ‚îú‚îÄ tcp_err.j2
   ‚îú‚îÄ tcp_ok.j2
   ‚îú‚îÄ https_method.j2
   ‚îú‚îÄ https_rc.j2
   ‚îú‚îÄ https_error.j2
   ‚îî‚îÄ fail_443_msg.j2
1) Templates Jinja
roles/satellite_precheck_kernel/templates/tcp_method.j2
Copy code
Jinja2
{%- if _tcp_nc is defined and (_tcp_nc.rc | default(127)) != 127 -%}
nc
{%- elif _tcp_telnet is defined and (_tcp_telnet.rc | default(127)) != 127 -%}
telnet
{%- elif _tcp_devtcp is defined -%}
devtcp
{%- else -%}
none
{%- endif -%}
roles/satellite_precheck_kernel/templates/tcp_rc.j2
Copy code
Jinja2
{%- if _tcp_nc is defined and (_tcp_nc.rc | default(127)) != 127 -%}
{{ _tcp_nc.rc | default(1) }}
{%- elif _tcp_telnet is defined and (_tcp_telnet.rc | default(127)) != 127 -%}
{{ _tcp_telnet.rc | default(1) }}
{%- elif _tcp_devtcp is defined -%}
{{ _tcp_devtcp.rc | default(1) }}
{%- else -%}
1
{%- endif -%}
roles/satellite_precheck_kernel/templates/tcp_err.j2
Copy code
Jinja2
{%- if _tcp_nc is defined and (_tcp_nc.rc | default(127)) != 127 -%}
{{ ((_tcp_nc.stderr | default('')) ~ ' ' ~ (_tcp_nc.stdout | default(''))) | trim }}
{%- elif _tcp_telnet is defined and (_tcp_telnet.rc | default(127)) != 127 -%}
{{ (_tcp_telnet.stdout | default('')) | trim }}
{%- elif _tcp_devtcp is defined -%}
{{ ((_tcp_devtcp.stderr | default('')) ~ ' ' ~ (_tcp_devtcp.stdout | default(''))) | trim }}
{%- else -%}
no tcp method available
{%- endif -%}
roles/satellite_precheck_kernel/templates/tcp_ok.j2
Copy code
Jinja2
{%- set m = sat_precheck_tcp_method | default('none') -%}
{%- if m == 'nc' -%}
{{ 'true' if ((_tcp_nc.rc | default(1)) == 0) else 'false' }}
{%- elif m == 'telnet' -%}
{%- set out = (_tcp_telnet.stdout | default('') | lower) -%}
{{ 'true' if ('connected' in out or 'open' in out) else 'false' }}
{%- elif m == 'devtcp' -%}
{{ 'true' if ((_tcp_devtcp.rc | default(1)) == 0) else 'false' }}
{%- else -%}
false
{%- endif -%}
roles/satellite_precheck_kernel/templates/https_method.j2
Copy code
Jinja2
{%- if _https_wget is defined and (_https_wget.rc | default(127)) != 127 -%}
wget
{%- elif _https_curl is defined and (_https_curl.rc | default(127)) != 127 -%}
curl
{%- else -%}
none
{%- endif -%}
roles/satellite_precheck_kernel/templates/https_rc.j2
Copy code
Jinja2
{%- if _https_wget is defined and (_https_wget.rc | default(127)) != 127 -%}
{{ _https_wget.rc | default(127) }}
{%- elif _https_curl is defined and (_https_curl.rc | default(127)) != 127 -%}
{{ _https_curl.rc | default(127) }}
{%- else -%}
127
{%- endif -%}
roles/satellite_precheck_kernel/templates/https_error.j2
Copy code
Jinja2
{%- if _https_wget is defined and (_https_wget.rc | default(127)) not in [0,127] -%}
{{ ((_https_wget.stderr | default('')) ~ ' ' ~ (_https_wget.stdout | default(''))) | trim }}
{%- elif _https_curl is defined and (_https_curl.rc | default(127)) not in [0,127] -%}
{{ ((_https_curl.stderr | default('')) ~ ' ' ~ (_https_curl.stdout | default(''))) | trim }}
{%- else -%}
{%- endif -%}
roles/satellite_precheck_kernel/templates/fail_443_msg.j2
Copy code
Jinja2
Satellite precheck FAILED (TCP 443)

Host       : {{ inventory_hostname }}
Capsule    : {{ sat_precheck.capsule | default('unknown') }}
DNS output : {{ sat_precheck.dns_ahosts | default('') }}

TCP method : {{ sat_precheck.tcp_method | default('none') }}
TCP 443 OK : {{ sat_precheck.port_443_ok | default(false) }}
TCP rc     : {{ sat_precheck.tcp_rc | default('N/A') }}
TCP error  : {{ sat_precheck.tcp_err | default('') }}

--> Port 443 MUST be reachable (closed/timeout/refused = FAILED).
2) roles/satellite_precheck_kernel/tasks/main.yml (complet)
Copy code
Yaml
---
# Scalable for thousands of hosts:
# - Collect evidence with failed_when:false on probes
# - Fail per-host OUTSIDE block/rescue
# - Fail job globally at end if any host has port_443_ok=false

- name: Init derived variables
  ansible.builtin.set_fact:
    sat_precheck_tcp_timeout: "{{ sat_precheck_tcp_timeout | default(5) | int }}"
    sat_precheck_https_timeout: "{{ sat_precheck_https_timeout | default(10) | int }}"
    sat_precheck_validate_certs: "{{ sat_precheck_validate_certs | default(false) | bool }}"
    sat_precheck_tmp_dir: "{{ sat_precheck_tmp_dir | default('/tmp') }}"
    sat_precheck_kernel_base_path: "{{ sat_precheck_kernel_base_path | default('/pub/kernel_versions') }}"
    sat_precheck_kernel_file_prefix: "{{ sat_precheck_kernel_file_prefix | default('kernel_version') }}"
    sat_precheck_arch: "{{ sat_precheck_arch | default(ansible_architecture | default('x86_64')) }}"
  changed_when: false

- name: Set RHEL major
  ansible.builtin.set_fact:
    sat_precheck_rhel_major: "{{ ansible_distribution_major_version | string }}"
  changed_when: false

- name: Build URL and tmp file path
  ansible.builtin.set_fact:
    sat_precheck_kernel_file: "{{ sat_precheck_kernel_file_prefix }}-{{ sat_precheck_rhel_major }}-{{ sat_precheck_arch }}"
    sat_precheck_kernel_url: "https://{{ sat_precheck_capsule_fqdn }}{{ sat_precheck_kernel_base_path }}/{{ sat_precheck_kernel_file }}"
    sat_precheck_tmp_file: "{{ sat_precheck_tmp_dir }}/{{ sat_precheck_kernel_file }}.{{ inventory_hostname }}.{{ ansible_date_time.epoch }}"
  changed_when: false

- name: Init result dict
  ansible.builtin.set_fact:
    sat_precheck:
      capsule: "{{ sat_precheck_capsule_fqdn }}"
      rhel_major: "{{ sat_precheck_rhel_major }}"
      arch: "{{ sat_precheck_arch }}"
      kernel_file: "{{ sat_precheck_kernel_file }}"
      url: "{{ sat_precheck_kernel_url }}"
      tmp_file: "{{ sat_precheck_tmp_file }}"
      dns_ahosts: ""
      tcp_method: "none"
      tcp_rc: null
      tcp_err: ""
      port_443_ok: false
      https_method: "none"
      https_rc: null
      https_error: ""
      file_exists: false
      file_size: 0
      download_ok: false
      kernel_version: ""
  changed_when: false

# ============================================================
# Collect block (no hard fail here)
# ============================================================
- name: Collect precheck evidence (DNS/TCP/HTTPS)
  block:

    # DNS
    - name: DNS resolution (getent ahosts)
      ansible.builtin.command: "getent ahosts {{ sat_precheck_capsule_fqdn }}"
      register: _dns
      changed_when: false
      failed_when: false

    - name: Save DNS output
      ansible.builtin.set_fact:
        sat_precheck: "{{ sat_precheck | combine({'dns_ahosts': (_dns.stdout | default('') | trim)}) }}"
      changed_when: false

    # TCP: nc -> telnet -> devtcp
    - name: TCP 443 via nc (if present)
      ansible.builtin.shell: |
        set -o pipefail
        command -v nc >/dev/null 2>&1 || exit 127
        nc -vz -w {{ sat_precheck_tcp_timeout }} {{ sat_precheck_capsule_fqdn }} 443
      args:
        executable: /bin/bash
      register: _tcp_nc
      changed_when: false
      failed_when: false

    - name: TCP 443 via telnet (if nc missing)
      ansible.builtin.shell: |
        set -o pipefail
        command -v telnet >/dev/null 2>&1 || exit 127
        (echo quit | timeout {{ sat_precheck_tcp_timeout | int + 2 }} telnet {{ sat_precheck_capsule_fqdn }} 443) 2>&1 | tail -n 20
      args:
        executable: /bin/bash
      register: _tcp_telnet
      changed_when: false
      failed_when: false
      when: (_tcp_nc.rc | default(127)) == 127

    - name: TCP 443 via /dev/tcp (if nc+telnet missing)
      ansible.builtin.shell: |
        set -o pipefail
        timeout {{ sat_precheck_tcp_timeout }} bash -lc 'echo >/dev/tcp/{{ sat_precheck_capsule_fqdn }}/443'
      args:
        executable: /bin/bash
      register: _tcp_devtcp
      changed_when: false
      failed_when: false
      when:
        - (_tcp_nc.rc | default(127)) == 127
        - _tcp_telnet is not defined or (_tcp_telnet.rc | default(127)) == 127

    - name: Compute TCP facts (templates)
      ansible.builtin.set_fact:
        sat_precheck_tcp_method: "{{ lookup('template', 'tcp_method.j2') | trim }}"
        sat_precheck_tcp_rc: "{{ (lookup('template', 'tcp_rc.j2') | trim) | int }}"
        sat_precheck_tcp_err: "{{ lookup('template', 'tcp_err.j2') | trim }}"
      changed_when: false

    - name: Compute TCP ok (template)
      ansible.builtin.set_fact:
        sat_precheck_port_443_ok_str: "{{ lookup('template', 'tcp_ok.j2') | trim }}"
      changed_when: false

    - name: Save TCP results
      ansible.builtin.set_fact:
        sat_precheck: "{{ sat_precheck | combine({
          'tcp_method': sat_precheck_tcp_method,
          'tcp_rc': sat_precheck_tcp_rc,
          'tcp_err': sat_precheck_tcp_err,
          'port_443_ok': (sat_precheck_port_443_ok_str == 'true')
        }) }}"
      changed_when: false

    # HTTPS GET only if port 443 OK
    - name: HTTPS GET via wget (if present)
      ansible.builtin.shell: |
        set -o pipefail
        command -v wget >/dev/null 2>&1 || exit 127
        EXTRA=""
        {% if not sat_precheck_validate_certs %}EXTRA="--no-check-certificate"{% endif %}
        wget -O "{{ sat_precheck_tmp_file }}" -S --timeout={{ sat_precheck_https_timeout }} --tries=1 $EXTRA "{{ sat_precheck_kernel_url }}"
      args:
        executable: /bin/bash
      register: _https_wget
      changed_when: false
      failed_when: false
      when: sat_precheck.port_443_ok | bool

    - name: HTTPS GET via curl (if wget missing)
      ansible.builtin.shell: |
        set -o pipefail
        command -v curl >/dev/null 2>&1 || exit 127
        EXTRA=""
        {% if not sat_precheck_validate_certs %}EXTRA="-k"{% endif %}
        curl $EXTRA -sS --connect-timeout {{ sat_precheck_tcp_timeout }} --max-time {{ sat_precheck_https_timeout }} \
          -o "{{ sat_precheck_tmp_file }}" "{{ sat_precheck_kernel_url }}"
      args:
        executable: /bin/bash
      register: _https_curl
      changed_when: false
      failed_when: false
      when:
        - sat_precheck.port_443_ok | bool
        - _https_wget is not defined or (_https_wget.rc | default(127)) == 127

    - name: Stat downloaded file (proof)
      ansible.builtin.stat:
        path: "{{ sat_precheck_tmp_file }}"
      register: _st
      changed_when: false
      failed_when: false
      when: sat_precheck.port_443_ok | bool

    - name: Compute HTTPS facts (templates)
      ansible.builtin.set_fact:
        sat_precheck_https_method: "{{ lookup('template', 'https_method.j2') | trim }}"
        sat_precheck_https_rc: "{{ (lookup('template', 'https_rc.j2') | trim) | int }}"
        sat_precheck_https_error: "{{ lookup('template', 'https_error.j2') | trim }}"
      changed_when: false
      when: sat_precheck.port_443_ok | bool

    - name: Save HTTPS results
      ansible.builtin.set_fact:
        sat_precheck: "{{ sat_precheck | combine({
          'https_method': (sat_precheck_https_method | default('none')),
          'https_rc': (sat_precheck_https_rc | default(127)),
          'https_error': (sat_precheck_https_error | default('')),
          'file_exists': (_st.stat.exists | default(false)),
          'file_size': (_st.stat.size | default(0) | int),
          'download_ok': ((_st.stat.exists | default(false)) and ((_st.stat.size | default(0) | int) > 0))
        }) }}"
      changed_when: false
      when: sat_precheck.port_443_ok | bool

    - name: Read downloaded file content (kernel_version)
      ansible.builtin.command: "cat {{ sat_precheck_tmp_file }}"
      register: _cat
      changed_when: false
      failed_when: false
      when: sat_precheck.download_ok | bool

    - name: Save kernel_version
      ansible.builtin.set_fact:
        sat_precheck: "{{ sat_precheck | combine({'kernel_version': (_cat.stdout | default('') | trim)}) }}"
      changed_when: false
      when: sat_precheck.download_ok | bool

  rescue:
    # On n'√©crase pas tout, on marque juste ce host comme KO et on continue
    - name: Mark host as KO on exception
      ansible.builtin.set_fact:
        sat_precheck: "{{ sat_precheck | combine({
          'tcp_method': (sat_precheck.tcp_method | default('none')),
          'tcp_rc': (sat_precheck.tcp_rc | default(1)),
          'tcp_err': (sat_precheck.tcp_err | default('exception during precheck')),
          'port_443_ok': false
        }) }}"
      changed_when: false

  always:
    - name: Cleanup downloaded file
      ansible.builtin.file:
        path: "{{ sat_precheck_tmp_file }}"
        state: absent
      changed_when: false
      failed_when: false

# ============================================================
# GLOBAL FAIL (job must be FAILED if any host has port_443_ok=false)
# NOTE: reliable with default strategy=linear
# ============================================================
- name: Collect failed hosts (TCP 443 KO) - global
  ansible.builtin.set_fact:
    sat_precheck_failed_hosts: >-
      {{
        ansible_play_hosts_all
        | select('in', hostvars.keys())
        | select(lambda h: (hostvars[h].sat_precheck is defined) and
                         (hostvars[h].sat_precheck.port_443_ok is defined) and
                         (not (hostvars[h].sat_precheck.port_443_ok | bool)))
        | list
      }}
  run_once: true
  delegate_to: localhost
  changed_when: false

- name: FAIL job if any host has TCP 443 KO
  ansible.builtin.fail:
    msg: >-
      Satellite precheck FAILED: TCP/443 KO sur {{ sat_precheck_failed_hosts | length }} host(s):
      {{ sat_precheck_failed_hosts | join(', ') }}
  when: sat_precheck_failed_hosts | length > 0
  run_once: true
  delegate_to: localhost

# ============================================================
# PER-HOST FAIL (host should be FAILED, but play continues for others)
# ============================================================
- name: FAIL this host if TCP 443 is NOT reachable
  ansible.builtin.fail:
    msg: "{{ lookup('template', 'fail_443_msg.j2') }}"
  when: not sat_precheck.port_443_ok | bool

- name: Debug sat_precheck (ok hosts)
  ansible.builtin.debug:
    var: sat_precheck
  changed_when: false
‚úÖ Ce que tu obtiens
Host A port 443 KO ‚áí FAILED (avec message complet)
Host B port 443 OK ‚áí continue (wget/curl + preuve)
√Ä la fin : si au moins 1 KO ‚áí le job AAP devient FAILED (pas succ√®s)
Si ton playbook utilise strategy: free
Dis-moi et je te donne la version ultra-fiable en 2 plays (le 1er ex√©cute le r√¥le, le 2e fait uniquement le ‚Äúfail global‚Äù apr√®s que tout le monde ait fini).